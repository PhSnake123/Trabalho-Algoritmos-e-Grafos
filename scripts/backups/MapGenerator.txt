# Em res://scripts/MapGenerator.gd
class_name MapGenerator

# Carrega nossos novos modelos de tile
const PAREDE: MapTileData = preload("res://assets/tileinfo/parede.tres")
const CHAO: MapTileData = preload("res://assets/tileinfo/chao.tres")
const DANO: MapTileData = preload("res://assets/tileinfo/dano.tres")
const BLOCK: MapTileData = preload("res://assets/tileinfo/bloco.tres")

# 2. Constantes do 'world_map.py'
const LARGURA = 51
const ALTURA = 31

# 3. Tradução do 'gerar_grid()'
# Retorna um Array 2D preenchido com PAREDE
func gerar_grid():
	var grid = []
	for y in range(ALTURA):
		var linha: Array[MapTileData] = []
		for x in range(LARGURA):
			linha.push_back(PAREDE)
		grid.push_back(linha)
	return grid

# 4. Tradução do 'gerar_labirinto_dfs()'
# Esta é a sua lógica de Randomized DFS, traduzida 1-para-1
func gerar_labirinto_dfs(grid, x, y):
	var pilha = []
	pilha.push_back(Vector2i(x, y)) # Vector2i é como uma tupla (x, y) de inteiros
	grid[y][x] = CHAO

	while not pilha.is_empty():
		var pos_atual = pilha.back() # .back() é o mesmo que pilha[-1] em Python
		var vizinhos = _obter_vizinhos_validos(grid, pos_atual.x, pos_atual.y)

		if not vizinhos.is_empty():
			var proxima_pos = vizinhos.pick_random() # .pick_random() é o random.choice()
			_cavar_caminho(grid, pos_atual, proxima_pos)
			pilha.push_back(proxima_pos)
		else:
			pilha.pop_back() # .pop_back() é o pilha.pop()

# --- Funções Auxiliares (Helpers) ---

# Nota: Funções que começam com '_' são consideradas "privadas"
func _direcoes_dfs():
	return [Vector2i(0, -2), Vector2i(0, 2), Vector2i(-2, 0), Vector2i(2, 0)]

func _coordenada_valida(x, y):
	return (x >= 0 and x < LARGURA and y >= 0 and y < ALTURA)

func _celula_eh_parede(grid, x, y):
	var tile = grid[y][x] as MapTileData
	# Se o 'as' funcionar, 'tile' será um MapTileData.
	# Se falhar (ex: o tile for nulo), 'tile' será 'null'.
	if tile:
		return not tile.passavel

	# Se o tile for nulo por algum motivo, é mais seguro
	# tratá-lo como uma parede (não passável).
	return true

func _obter_vizinhos_validos(grid, x, y):
	var vizinhos_validos = []
	for dir in _direcoes_dfs():
		var nx = x + dir.x
		var ny = y + dir.y
		
		if _coordenada_valida(nx, ny) and _celula_eh_parede(grid, nx, ny):
			vizinhos_validos.push_back(Vector2i(nx, ny))
	
	return vizinhos_validos

func _marcar_como_chao(grid, x, y):
	grid[y][x] = CHAO

func _cavar_caminho(grid, pos1, pos2):
	var meio_x = (pos1.x + pos2.x) / 2
	var meio_y = (pos1.y + pos2.y) / 2
	grid[meio_y][meio_x] = CHAO
	_marcar_como_chao(grid, pos2.x, pos2.y)

# Esta função cria atalhos e loops, quebrando paredes internas.
func quebrar_paredes_internas(grid, porcentagem_quebra = 0.15):
	# Itera pelo grid, mas evita as bordas externas (range 1 até -1)
	for y in range(1, ALTURA - 1):
		for x in range(1, LARGURA - 1):
			
			# Se este tile for uma parede, veja se é uma "parede interna"
			if grid[y][x] == PAREDE:
				
				# Checa se é uma parede "horizontal" (chão em cima e embaixo)
				if grid[y-1][x] == CHAO and grid[y+1][x] == CHAO:
					if randf() < porcentagem_quebra: # randf() = float aleatório 0.0 a 1.0
						grid[y][x] = CHAO
				
				# Checa se é uma parede "vertical" (chão à esquerda e à direita)
				elif grid[y][x-1] == CHAO and grid[y][x+1] == CHAO:
					if randf() < porcentagem_quebra:
						grid[y][x] = CHAO

# Em res://scripts/MapGenerator.gd
# SUBSTITUA a função 'adicionar_terrenos_especiais' inteira por esta:

func adicionar_terrenos_especiais(grid, total_lava: int, total_portas: int, inicio_pos: Vector2i):
	
	var tentativas_max = LARGURA * ALTURA # Safety break para evitar loops infinitos
	
	# --- 1. LÓGICA DE COLOCAÇÃO DE LAVA ---
	var lava_colocada = 0
	var tentativas = 0
	while lava_colocada < total_lava and tentativas < tentativas_max:
		# Pega um local aleatório
		var x = randi_range(1, LARGURA - 2)
		var y = randi_range(1, ALTURA - 2)
		
		# Pergunta se é um local "bom"
		if _pode_colocar_lava(grid, x, y, inicio_pos):
			grid[y][x] = DANO
			lava_colocada += 1
		
		tentativas += 1
	
	# --- 2. LÓGICA DE COLOCAÇÃO DE PORTA ---
	var portas_colocadas = 0
	tentativas = 0 # Reseta as tentativas
	while portas_colocadas < total_portas and tentativas < tentativas_max:
		var x = randi_range(1, LARGURA - 2)
		var y = randi_range(1, ALTURA - 2)
		
		# Pergunta se é um local "bom"
		if _pode_colocar_porta(grid, x, y):
			grid[y][x] = BLOCK
			portas_colocadas += 1
		
		tentativas += 1

# Conta quantos dos 8 vizinhos de (x, y) são do tipo 'tile_alvo'
func _contar_vizinhos(grid, x, y, tile_alvo: MapTileData) -> int:
	var contagem = 0
	for dy in [-1, 0, 1]:
		for dx in [-1, 0, 1]:
			# Pula o próprio tile
			if dx == 0 and dy == 0:
				continue
			
			var nx = x + dx
			var ny = y + dy
			
			# Checa se é válido e se é o tile que procuramos
			if _coordenada_valida(nx, ny) and grid[ny][nx] == tile_alvo:
				contagem += 1
	return contagem
	
	# Em res://scripts/MapGenerator.gd (adicione no final)

# --- NOVA FUNÇÃO DE VALIDAÇÃO (LAVA) ---
func _pode_colocar_lava(grid, x, y, inicio_pos: Vector2i) -> bool:
	var pos = Vector2i(x, y)
	
	# Regra 1: Só pode ser colocado sobre o CHAO
	if grid[y][x] != CHAO:
		return false
		
	# Regra 2: Não pode ser no início do jogador
	if pos == inicio_pos:
		return false
		
	# Regra 3: Deve estar a uma distância mínima do início
	# (Usamos distância de Manhattan por ser mais simples)
	var distancia = abs(pos.x - inicio_pos.x) + abs(pos.y - inicio_pos.y)
	if distancia < 10: # Distância mínima de 10 tiles
		return false
		
	return true # Passou em todas as regras!

# --- VALIDAÇÃO (PORTA) ---

# Em res://scripts/MapGenerator.gd
# SUBSTITUA a função inteira por esta:

func _pode_colocar_porta(grid, x, y) -> bool:
	
	# Regra 1: Só pode ser colocado sobre uma PAREDE
	if grid[y][x] != PAREDE:
		return false
		
	# Regra 2: Não pode ter outra PORTA por perto (evita agrupamento)
	if _contar_vizinhos(grid, x, y, BLOCK) > 0:
		return false
		
	# Regra 3: Validar se é uma "parede divisória"
	var chao_acima = (grid[y-1][x] == CHAO)
	var chao_abaixo = (grid[y+1][x] == CHAO)
	var chao_esquerda = (grid[y][x-1] == CHAO)
	var chao_direita = (grid[y][x+1] == CHAO)
	
	var eh_parede_vertical = chao_acima and chao_abaixo
	var eh_parede_horizontal = chao_esquerda and chao_direita
	
	# Regra 4: Deve ser vertical OU horizontal, mas NÃO AMBAS (XOR).
	# Se (ambos true) ou (ambos false), é inválido.
	# (ambos true) == pilar isolado
	# (ambos false) == parede sólida (não-interna)
	if eh_parede_vertical == eh_parede_horizontal:
		return false
	
	# Regra 5: Evitar "pontas"
	if eh_parede_vertical:
		# Se é uma parede vertical, deve ter paredes dos lados para se "apoiar"
		if grid[y][x-1] != PAREDE or grid[y][x+1] != PAREDE:
			return false # É uma "ponta" de parede vertical, rejeita.
	
	if eh_parede_horizontal:
		# Se é uma parede horizontal, deve ter paredes em cima/embaixo
		if grid[y-1][x] != PAREDE or grid[y+1][x] != PAREDE:
			return false # É uma "ponta" de parede horizontal, rejeita.
			
	return true # Passou em todas as regras!
